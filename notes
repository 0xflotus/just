notes
-----

- comment code
- fix docs (note that shell is invoked with -cu)
- publish to github and cargo

polyglot:
- recipes can have shebangs
- extract and run script
- preserve line numbers
- special 'prelude recipe"
  . allow launching binaries from cargo
  . script until --
  . all recipes are then in that language?

extras:
- args can be passed after --, or with some special syntax:
  a: 1 2 3 :
- should also add an annotation for recipes
  a FOO BAR, export variables FOO and BAR with args
- indent for line continuation
- use launch recipes asyncronously
- ~/.justfile: 
  . is this for non-project specific commands, so that when you
    type .j in any directory, it uses it as a justfile?
  . or is it for commands which are useful across projects?
- super complex recipe lines:
  a: b c # run b and c, then a
  b | a: c # run c, then b, and pipe output of b into a
  a >> a.log: # run a and append output to a.log
  a B C: # a takes B and C as command line args, like j a HELLO BOB
         # can enforce at command line
- what is the story for allowing justfiles in subdirectories?
  use a different name, like 'subjustfile' or 'jfile'.
  recurse up to the justfile, but add recipes in any jfile
  that you find along the way. recipes in justfile are accessible,
  and run from the justfile dir. recipes in jfile are run from jfile
  dir. refuse to run if a recipe in justfile and jfile conflict
- rust is a given, so one option is to write a very simple shell
  command parser and use that instead of the system shell. this
  would make recipes work across systems with incompatible shells.
  additionally, we could also define a mode where it will only call
  commands from cargo, which would make recipes work across systems
  with incompatible userlands 'rc' or 'cargo cult' is a great name
