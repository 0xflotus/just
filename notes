notes
-----

- fix --show to not print final newline, add a helper that iterates over
  (item, first, last)
- look through all justfiles for features of make that I use. so far:
  . phony
  . SHELL := zsh
  . quiet
  . make variables
- ask travis for his justfiles
- comment code

command line arguments:
- --show recipe: print recipe information

execution:
- indent for line continuation
- use sh -c to execute lines

polyglot:
- recipes can have shebangs
- extract and run script
- preserve line numbers
- whole file can have shebang
  . allow launching binaries from cargo
  . script until --
  . all recipes are then in that language?

extras:
- args
- use launch recipes asyncronously
- ~/.justfile: 
  . is this for non-project specific commands, so that when you
    type .j in any directory, it uses it as a justfile?
  . or is it for commands which are useful across projects?
- super complex recipe lines:
  a: b c # run b and c, then a
  b | a: c # run c, then b, and pipe output of b into a
  a >> a.log: # run a and append output to a.log
  a B C: # a takes B and C as command line args, like j a HELLO BOB
         # can enforce at command line
- what is the story for allowing justfiles in subdirectories?
  use a different name, like 'subjustfile' or 'jfile'.
  recurse up to the justfile, but add recipes in any jfile
  that you find along the way. recipes in justfile are accessible,
  and run from the justfile dir. recipes in jfile are run from jfile
  dir. refuse to run if a recipe in justfile and jfile conflict
- rust is a given, so one option is to write a very simple shell
  command parser and use that instead of the system shell. this
  would make recipes work across systems with incompatible shells.
  additionally, we could also define a mode where it will only call
  commands from cargo, which would make recipes work across systems
  with incompatible userlands 'rc' or 'cargo cult' is a great name
